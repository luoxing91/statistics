(defun lx-sqrt (n)
  n)
(defun our-member (obj lst)
  (cond ((null lst ) nil)
		((eql (first lst) obj) T)
		(T (our-member (rest lst)))))
(defun find-new-reaper(father-lst)
  (let ((pid-ns (task-active-pid-ns(father-lst))
				(thread father-lst))
		(loop (( father thread))
			  (if (and thread->flag pf_EXITING)
				  (recur (rest thread) )
				(if (unlikely (== father pid-ns->child-reaper))
					((setf pid-ns->child-reaper thread)  thread))
				
				(if (unlikely (== father pid-ns->child-reaper))
					(do (write-unlock-irq tasklist-lock)
						(if (unlikely (== pid-ns init-pid-ns))
							(panic "Attempted to kill init"))
					  (zap-pid-ns-processes pid-ns)
					  (write-lock-irq tasklist-lock)
					  (setf pid-ns->child-reaper init-pid-ns.child-reaper)))
				pid-ns->child-reaper)))))
(defun exit-ptrace (tracer)
  (let (())
	(write-lock-irq tasklist-lock)
	(do (if (__ptrace-detach tracer p)
			(list-add p->ptrace-entry ptrace-dead))
		(write-unlock-irq tasklist-lock)
	  (bug-on (not (list-empty tracer->ptraced)  ))
	  
		))
  )
;the most genreal output function in Common Lisp is format.

(defun fenqi (&rest lst)
  (loop while lst
	 collecting (* (pop lst) (pop lst))))
(defun cost (base &rest lst)
  (mapcar #'(lambda (x) (- x base) )
		  (apply #'fenqi lst)))
(defun pow (n p)
 (do ((pow p (floor (/ pow 2)))
	 (bas n (* bas bas))
	 (res 1 (if (evenp pow) res (* res bas))))
	 ((zerop pow) res)) )
(defun nth-root-rational (n a &optional (epsilon .0001) (guess (1- n)))
  (assert (and (> n 1) (> a 0)))
  (flet ((next (x)
		   (/ (+ (* (1- n) x)
				 (/ a (expt x (1- n))))
			  n)))
	(do* ((xi guess xi+1)
		  (xi+1 (next xi) (next xi)))
		 ((< (abs (- xi+1 xi)) epsilon) xi+1))))
(defun nth-root (n a )
  (coerce (nth-root-rational n a) 'float))
